package {{package}}

{{#imports}}import {{import}}
{{/imports}}
import org.http4s.{Header, Headers, Request, Uri}
import org.http4s.client.blaze._
import org.http4s.dsl._
import org.http4s.argonaut._
import org.http4s.client.Client
import argonaut._, Argonaut._

import scalaz.concurrent.Task
import scala.collection.mutable

{{#operations}}
class {{classname}}(client: Client, baseUri: Uri) {

  {{#operation}}
  def {{operationId}}({{#allParams}}{{^required}}{{paramName}}: Option[{{dataType}}] = {{#defaultValue}}Some("{{defaultValue}}"){{/defaultValue}}{{^defaultValue}}None{{/defaultValue}}{{#hasMore}},{{/hasMore}}
      {{/required}}{{#required}}{{paramName}}: {{dataType}}{{#defaultValue}} = {{{defaultValue}}}{{/defaultValue}}{{#hasMore}},
      {{/hasMore}}{{/required}}{{/allParams}})(implicit {{#bodyParam}}encoder: EncodeJson[{{dataType}}],{{/bodyParam}} decoder: DecodeJson[{{returnType}}{{^returnType}}Unit{{/returnType}}]){{#returnType}}: Task[{{returnType}}]{{/returnType}}{{^returnType}}: Task[Unit]{{/returnType}} = {
    // create path and map variables
    val path = baseUri / (("{{path}}"){{#pathParams}} replaceAll ("\\{" + "{{baseName}}" + "\\}",{{paramName}}.toString){{/pathParams}})

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    {{#allParams}}
    {{#required}}
    {{^isPrimitiveType}}
    if ({{paramName}} == null) throw new Exception("Missing required parameter '{{paramName}}' when calling {{classname}}->{{operationId}}")

    {{/isPrimitiveType}}
    {{/required}}
    {{/allParams}}
    {{#queryParams}}
    {{^required}}
    if ({{paramName}} != null) {{paramName}}.foreach { v => queryParams += "{{baseName}}" -> v.toString }

    {{/required}}
    {{#required}}
    if ({{paramName}} != null) queryParams += "{{baseName}}" -> {{paramName}}.toString

    {{/required}}
    {{/queryParams}}

    {{#headerParams}}
    headerParams += "{{baseName}}" -> {{paramName}}.toString
    {{/headerParams}}

    val requestWithQueryParams  = queryParams.foldLeft(path) { case (req, (k, v)) => req.withQueryParam(k, v)}
    val headers = Headers(headerParams.map{ case (k, v) => Header(k, v)}.toList)
    val fullReq = Request(method = {{httpMethod}}, uri = requestWithQueryParams, headers = headers)

    val fullReqWithBody = {{#bodyParam}}{{#required}}fullReq.withBody({{paramName}})(jsonEncoderOf(encoder)){{/required}}{{^required}}{{paramName}}.foldLeft(fullReq){(r, p) => r.withBody(p)(jsonEncoderOf(encoder)).run}{{/required}}{{/bodyParam}}{{^bodyParam}}fullReq{{/bodyParam}}

    client.fetchAs(fullReqWithBody)(jsonOf(decoder))
  }

  {{/operation}}

}
{{/operations}}
