package {{package}}

{{#imports}}import {{import}}
{{/imports}}
import org.http4s.{Header, Headers, Request, Uri}
import org.http4s.client.blaze._
import org.http4s.dsl._
import org.http4s.argonaut._
import org.http4s.client.Client
import argonaut._, Argonaut._

import scalaz.concurrent.Task
import scala.collection.mutable

import scalaz._
import Scalaz._

{{#operations}}
class {{classname}}(client: Client, baseUri: Uri) {

  implicit def listShow[T](implicit s: Show[T]): Show[List[T]] = new Show[List[T]] {
    override def shows(xs: List[T]): String = xs.foldLeft("") { (a, n) =>
      if (a == "") n.shows else a + "," + n.shows
    }
  }

  implicit object integerShow extends Show[Integer] {
    override def shows(i: Integer): String = i.toString
  }

  implicit object stringInstance extends Monoid[String] with Show[String] with Equal[String] with Order[String] with IsEmpty[({ type λ[α] = String })#λ] {
    type SA[α] = String
    def append(f1: String, f2: => String) = f1 + f2
    def zero: String = ""
    override def show(f: String) = f
    def order(x: String, y: String) = Ordering.fromInt(x.compareTo(y))
    override def equal(x: String, y: String) = x == y
    override def equalIsNatural: Boolean = true
    def empty[A] = zero
    def plus[A](f1: SA[A], f2: => SA[A]) = f1 + f2
    def isEmpty[A](s: SA[A]) = s == ""
  }

  {{#operation}}
  def {{operationId}}({{#allParams}}{{^required}}{{paramName}}: Option[{{dataType}}] = {{#defaultValue}}Some("{{defaultValue}}"){{/defaultValue}}{{^defaultValue}}None{{/defaultValue}}{{#hasMore}},{{/hasMore}}
      {{/required}}{{#required}}{{paramName}}: {{dataType}}{{#defaultValue}} = {{{defaultValue}}}{{/defaultValue}}{{#hasMore}},
      {{/hasMore}}{{/required}}{{/allParams}})(implicit {{#bodyParam}}encoder: EncodeJson[{{dataType}}],{{/bodyParam}} decoder: DecodeJson[{{returnType}}{{^returnType}}Unit{{/returnType}}]){{#returnType}}: Task[{{returnType}}]{{/returnType}}{{^returnType}}: Task[Unit]{{/returnType}} = {
    // create path and map variables
    val path = baseUri / (("{{path}}".stripPrefix("/")){{#pathParams}} replaceAll ("\\{" + "{{baseName}}" + "\\}",{{paramName}}.toString){{/pathParams}})

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    {{#allParams}}
    {{#required}}
    {{^isPrimitiveType}}
    if ({{paramName}} == null) throw new Exception("Missing required parameter '{{paramName}}' when calling {{classname}}->{{operationId}}")

    {{/isPrimitiveType}}
    {{/required}}
    {{/allParams}}
    {{#queryParams}}
    {{^required}}
    if ({{paramName}} != null) {{paramName}}.foreach { v => queryParams += "{{baseName}}" -> v.shows}

    {{/required}}
    {{#required}}
    if ({{paramName}} != null) queryParams += "{{baseName}}" -> ({{paramName}}.shows)

    {{/required}}
    {{/queryParams}}

    {{#headerParams}}
    headerParams += "{{baseName}}" -> {{paramName}}.shows
    {{/headerParams}}

    val requestWithQueryParams  = queryParams.foldLeft(path) { case (req, (k, v)) => req.withQueryParam(k, v)}
    val headers = Headers(headerParams.map{ case (k, v) => Header(k, v)}.toList)
    val fullReq = Request(method = {{httpMethod}}, uri = requestWithQueryParams, headers = headers)

    val fullReqWithBody = {{#bodyParam}}{{#required}}fullReq.withBody({{paramName}})(jsonEncoderOf(encoder)){{/required}}{{^required}}{{paramName}}.foldLeft(fullReq){(r, p) => r.withBody(p)(jsonEncoderOf(encoder)).run}{{/required}}{{/bodyParam}}{{^bodyParam}}fullReq{{/bodyParam}}

    client.fetchAs(fullReqWithBody)(jsonOf(decoder))
  }

  {{/operation}}

}
{{/operations}}
