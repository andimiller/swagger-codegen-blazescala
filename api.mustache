package {{package}}

{{#imports}}import {{import}}
{{/imports}}
import org.http4s.{Header, Headers, Request, Uri, OAuth2BearerToken}
import org.http4s.client.blaze._
import org.http4s.dsl._
import org.http4s.argonaut._
import org.http4s.client.Client
import org.http4s.headers.Authorization
import argonaut._, Argonaut._

import scalaz.concurrent.Task
import scala.collection.mutable

import scalaz.{:+: => _, Coproduct => _, _}
import Scalaz._
import querystringencoders.QueryStringEncoders._
import shapeless._

{{#operations}}
class {{classname}}(client: Client, baseUri: Uri) {

  {{#operation}}
  type {{operationId}}Errors = {{#responses}}{{^isDefault}}{{dataType}}{{#hasMore}} :+: {{/hasMore}}{{^hasMore}} :+: CNil{{/hasMore}}{{/isDefault}}{{/responses}}

  def {{operationId}}({{#allParams}}{{^required}}{{paramName}}: Option[{{dataType}}] = {{#defaultValue}}Some({{#isString}}"{{/isString}}{{defaultValue}}{{#isString}}"{{/isString}}){{/defaultValue}}{{^defaultValue}}None{{/defaultValue}}{{#hasMore}},{{/hasMore}}
      {{/required}}{{#required}}{{paramName}}: {{dataType}}{{#defaultValue}} = {{#isString}}"{{/isString}}{{{defaultValue}}}{{#isString}}"{{/isString}}{{/defaultValue}}{{#hasMore}},
      {{/hasMore}}{{/required}}{{/allParams}}, token: Option[String] = None)(implicit {{#bodyParam}}encoder: EncodeJson[{{dataType}}],{{/bodyParam}} decoder: DecodeJson[{{returnType}}{{^returnType}}Unit{{/returnType}}]{{#responses}}{{^isDefault}}{{dataType}}decoder: DecodeJson[{{dataType}}]{{/isDefault}}{{#hasMore}},{{/hasMore}}{{/responses}}){{#returnType}}: Task[\/[{{operationId}}Errors,{{returnType}}]]{{/returnType}}{{^returnType}}: Task[\/[{{operationId}}Errors,Unit]]{{/returnType}} = {
    // create path and map variables
    val path = baseUri / (("{{path}}".stripPrefix("/")){{#pathParams}} replaceAll ("\\{" + "{{baseName}}" + "\\}",{{paramName}}.toString){{/pathParams}})

    val queryParams = List[Option[(String, String)]](
    {{#queryParams}}
    {{^required}}
      {{paramName}}.map{ v => ("{{baseName}}" -> v.queryString)}
    {{/required}}
    {{#required}}
      Some("{{baseName}}" -> {{paramName}}.queryString)
    {{/required}}
    {{#hasMore}},{{/hasMore}}
    {{/queryParams}}
    ).flatten.toMap[String, String]

    val headerParams = List[Option[(String, String)]](
    {{#headerParams}}
    {{#required}}
      Some("{{baseName}}" -> {{paramName}}.queryString)
    {{/required}}
    {{^required}}
      {{paramName}}.map{ v => ("{{baseName}}" -> v.queryString)}
    {{/required}}
    {{#hasMore}},{{/hasMore}}
    {{/headerParams}}
    ).flatten.toMap[String, String]

    val requestWithQueryParams  = queryParams.foldLeft(path) { case (req, (k, v)) => req.withQueryParam(k, v)}
    val headers = Headers(headerParams.map{ case (k, v) => Header(k, v)}.toList)
    val fullReq = Request(method = {{httpMethod}}, uri = requestWithQueryParams, headers = headers)

    val fullReqWithToken = token.foldLeft(fullReq)((r, t) => r.copy(headers = r.headers.put(Authorization(OAuth2BearerToken(t)))))

    val fullReqWithBody = {{#bodyParam}}{{#required}}fullReqWithToken.withBody({{paramName}})(jsonEncoderOf(encoder)){{/required}}{{^required}}{{paramName}}.foldLeft(fullReq){(r, p) => r.withBody(p)(jsonEncoderOf(encoder)).run}{{/required}}{{/bodyParam}}{{^bodyParam}}fullReqWithToken{{/bodyParam}}

    client.fetch(fullReqWithBody) { resp =>
      val dec = resp.status.code match {
        case i if ((i>199) && (i<300)) => decoder.map(_.right[{{operationId}}Errors])
        {{#responses}}
        {{^isDefault}}case {{code}} => {{dataType}}decoder.map(x => Coproduct[{{operationId}}Errors](x).left[{{returnType}}{{^returnType}}Unit{{/returnType}}]){{/isDefault}}
        {{/responses}}
      }
      resp.as(jsonOf(dec))
    }
  }

  {{/operation}}

}
{{/operations}}
