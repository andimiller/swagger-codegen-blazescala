package {{package}}

{{#imports}}import {{import}}
{{/imports}}
import org.http4s.{Header, Headers, Request, Uri, OAuth2BearerToken}
import org.http4s.client.blaze._
import org.http4s.dsl._
import org.http4s.argonaut._
import org.http4s.client.Client
import org.http4s.headers.Authorization
import argonaut._, Argonaut._

import scalaz.concurrent.Task
import scala.collection.mutable

import scalaz.{:+: => _, Coproduct => _, _}
import Scalaz._
import querystringencoders.QueryStringEncoders._
import shapeless._

{{#operations}}
class {{classname}}(client: Client, baseUri: Uri) {

  {{#operation}}
  type {{operationId}}Errors = {{#responses}}{{^isDefault}}{{dataType}}{{#hasMore}} :+: {{/hasMore}}{{^hasMore}} :+: CNil{{/hasMore}}{{/isDefault}}{{/responses}}

  def {{operationId}}({{#allParams}}{{^required}}{{paramName}}: Option[{{dataType}}] = {{#defaultValue}}Some("{{defaultValue}}"){{/defaultValue}}{{^defaultValue}}None{{/defaultValue}}{{#hasMore}},{{/hasMore}}
      {{/required}}{{#required}}{{paramName}}: {{dataType}}{{#defaultValue}} = {{{defaultValue}}}{{/defaultValue}}{{#hasMore}},
      {{/hasMore}}{{/required}}{{/allParams}}, token: Option[String] = None)(implicit {{#bodyParam}}encoder: EncodeJson[{{dataType}}],{{/bodyParam}} decoder: DecodeJson[{{returnType}}{{^returnType}}Unit{{/returnType}}]{{#responses}}{{^isDefault}}{{dataType}}decoder: DecodeJson[{{dataType}}]{{/isDefault}}{{#hasMore}},{{/hasMore}}{{/responses}}){{#returnType}}: Task[\/[{{operationId}}Errors,{{returnType}}]]{{/returnType}}{{^returnType}}: Task[\/[{{operationId}}Errors,Unit]]{{/returnType}} = {
    // create path and map variables
    val path = baseUri / (("{{path}}".stripPrefix("/")){{#pathParams}} replaceAll ("\\{" + "{{baseName}}" + "\\}",{{paramName}}.toString){{/pathParams}})

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    {{#allParams}}
    {{#required}}
    {{^isPrimitiveType}}
    if ({{paramName}} == null) throw new Exception("Missing required parameter '{{paramName}}' when calling {{classname}}->{{operationId}}")

    {{/isPrimitiveType}}
    {{/required}}
    {{/allParams}}
    {{#queryParams}}
    {{^required}}
    if ({{paramName}} != null) {{paramName}}.foreach { v => queryParams += "{{baseName}}" -> v.queryString}

    {{/required}}
    {{#required}}
    if ({{paramName}} != null) queryParams += "{{baseName}}" -> ({{paramName}}.queryString)

    {{/required}}
    {{/queryParams}}

    {{#headerParams}}
    headerParams += "{{baseName}}" -> {{paramName}}.queryString
    {{/headerParams}}

    val requestWithQueryParams  = queryParams.foldLeft(path) { case (req, (k, v)) => req.withQueryParam(k, v)}
    val headers = Headers(headerParams.map{ case (k, v) => Header(k, v)}.toList)
    val fullReq = Request(method = {{httpMethod}}, uri = requestWithQueryParams, headers = headers)

    val fullReqWithToken = token.foldLeft(fullReq)((r, t) => r.copy(headers = r.headers.put(Authorization(OAuth2BearerToken(t)))))

    val fullReqWithBody = {{#bodyParam}}{{#required}}fullReqWithToken.withBody({{paramName}})(jsonEncoderOf(encoder)){{/required}}{{^required}}{{paramName}}.foldLeft(fullReq){(r, p) => r.withBody(p)(jsonEncoderOf(encoder)).run}{{/required}}{{/bodyParam}}{{^bodyParam}}fullReqWithToken{{/bodyParam}}

    val d = decoder.map(_.right[{{operationId}}Errors]){{#responses}}{{^isDefault}} ||| {{dataType}}decoder.map(x => Coproduct[{{operationId}}Errors](x).left[{{returnType}}{{^returnType}}Unit{{/returnType}}]){{/isDefault}}{{/responses}}

    client.fetchAs(fullReqWithBody)(jsonOf(d))
  }

  {{/operation}}

}
{{/operations}}
